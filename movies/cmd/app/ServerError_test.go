// ********RoostGPT********
/*
Test generated by RoostGPT for test go-test-assistent using AI Type  and AI Model 

ROOST_METHOD_HASH=serverError_b92d6368f4
ROOST_METHOD_SIG_HASH=serverError_fe161bb8ab

Scenario 1: When valid error is passed
```
Details:
  Description: The test is meant to check if a valid error object is passed, the serverError should log the error with a stack trace and return the HTTP 500 status.

Execution:
  Arrange: Implement a logger with LogWriter to write logs into memory, set up a response Recorder with a nil ResponseWriter.
  Act: Pass a new error into the serverError function.
  Assert: Assert the logger writes logs into memory, assert the ResponseRecorder received the HTTP 500 status.

Validation:
  The choice of assertion is to check the error logs are correctly written in logs and the correct status code is returned. This test ensures that server errors are handled appropriately and necessary information is logged.
```

Scenario 2: When the error object is nil
```
Details:
  Description: The test is meant to check if the error object is nil. As nil error doesn't generate stack trace, the serverError should log "nil" and return the HTTP 500 status.

Execution:
  Arrange: Implement a logger with LogWriter to write logs into memory, set up a response Recorder with a nil ResponseWriter.
  Act: Pass nil into the serverError function.
  Assert: Assert the logger writes "nil" into log and assert the ResponseRecorder received the HTTP 500 status.

Validation:
  The choice of assertion is based on the fact that nil error input should be logged as "nil" and still return the HTTP 500 status. This is an important test to cover the edge-case scenario when the error passed for logging is nil.
```

Scenario 3: When the http.ResponseWriter is nil
```
Details:
  Description: The test is meant to check the behavior of the serverError function when passed with a nil http.ResponseWriter. 

Execution:
  Arrange: Implement a logger with LogWriter to write logs into memory.
  Act: Pass a new error along with a nil http.ResponseWriter into the serverError function.
  Assert: Assert the logger writes the appropriate error message with the stack trace into the log.

Validation:
  The purpose of this assertion is to confirm that even if the http.ResponseWriter is nil, the error logging should still work. This is vital to ensure that in case of any abnormalities in creating the ResponseWriter, the server can still log the error effectively.
```

Scenario 4: When the logger is unable to write the logs
```
Details:
  Description: This test checks the behaviour of the serverError function when the logger is unable to write the logs.

Execution:
  Arrange: Implement a logger that throws errors whenever it tries to write logs, set up a response Recorder with a nil ResponseWriter.
  Act: Pass a new error into the serverError function.
  Assert: Assert that the logger's Output method was called and the error was caught.

Validation:
  The assertion is designed to confirm that the function handles situations where the logger is unable to write the logs and the exceptions are correctly propagated. This is important for proper error handling and logging mechanism.
```
*/

// ********RoostGPT********
package main

import (
	"bytes"
	"errors"
	"log"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
)

func TestServerError(t *testing.T) {
	app := &application{
		errorLog: log.New(&bytes.Buffer{}, "", 0),
	}

	tests := []struct {
		name         string
		err          error
		expectOutput string
	}{
		{
			name:         "When valid error is passed",
			err:          errors.New("test error"),
			expectOutput: "test error",
		},
		{
			name:         "When the error object is nil",
			err:          nil,
			expectOutput: "<nil>",
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			rec := httptest.NewRecorder()
			app.serverError(rec, tc.err)

			res := rec.Result()
			defer res.Body.Close()

			if res.StatusCode != http.StatusInternalServerError {
				t.Errorf("expected %d to be %d", res.StatusCode, http.StatusInternalServerError)
			}

			logged := app.errorLog.Writer().(*bytes.Buffer).String()
			if !strings.Contains(logged, tc.expectOutput) {
				t.Errorf("expected %q to be in %q", tc.expectOutput, logged)
			}
		})
	}

	t.Run("When the http.ResponseWriter is nil", func(t *testing.T) {
		app.serverError(nil, errors.New("test error"))
		logged := app.errorLog.Writer().(*bytes.Buffer).String()

		if !strings.Contains(logged, "test error") {
			t.Errorf("expected %q to be in %q", "test error", logged)
		}
	})

	t.Run("When the logger is unable to write the logs", func(t *testing.T) {
		app := &application{
			errorLog: log.New(errorWriter{}, "", 0),
		}
		app.serverError(httptest.NewRecorder(), errors.New("test error"))
	})
}

type errorWriter struct{}

func (ew errorWriter) Write(p []byte) (n int, err error) {
	return 0, errors.New("test error")
}
