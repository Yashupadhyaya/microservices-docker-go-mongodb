// ********RoostGPT********
/*
Test generated by RoostGPT for test azure-test-assistent using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=insert_6526688601
ROOST_METHOD_SIG_HASH=insert_f90e997c71

Scenario 1: Test for Valid Movie Insert

Details:
    Description: This test is used to validate that the function can successfully insert a new movie into the database. The target scenario is the normal, expected use of the function.
Execution:
    Arrange: Set up a mock application struct with a logger and a mock MovieModel that returns a successful result. Also, create a valid movie object to insert.
    Act: Invoke the insert function with the constructed application struct and a http request that contains the movie object in its body.
    Assert: Use Go testing facilities to check that the function does not return any errors and that the mock MovieModel's Insert function was called with the right parameters.
Validation:
    The assertion checks that the function followed the right flow for a successful insert and called the appropriate functions with the right parameters. This ensures that the function behaves correctly during normal operation.


Scenario 2: Invalid Movie Data 

Details:
    Description: This test is designed to ascertain how the function handles cases where the incoming http request does not contain valid movie data. The target scenario is an edge case where there is malformed or invalid data in the request.
Execution:
    Arrange: Set up a mock application struct with a logger and a mock MovieModel. Create a http request with an invalid movie object in its body.
    Act: Invoke the insert function with the constructed application struct and the http request containing the invalid movie.
    Assert: Verify that the function returns an error and that the mock MovieModel's Insert function was not called.
Validation:
    The assertion checks that the function correctly identifies invalid data and does not attempt to insert it into the database. The error handling in this scenario is critical, as insertion of invalid data can lead to inconsistent state in the database.


Scenario 3: Database Insert Failure

Details:
    Description: This test is intended to test how the function reacts when there is a failure in inserting the movie into the database. The target scenario is an edge case where there is an error with the database operation.
Execution:
    Arrange: Set up a mock application struct with a logger and a mock MovieModel that returns an error when its Insert function is called. Also, create a valid movie object to insert.
    Act: Invoke the insert function with the constructed application struct and a http request that contains the movie object.
    Assert: Verify that the function returns an error and the error message matches the error from the mocked MovieModel's Insert function.
Validation:
    The assertion checks that the function correctly handles errors from the underlying database operation. This is important in maintaining the robustness and reliability of the application. Even in case of database errors, the function should not crash and should return a meaningful error to the caller.
*/

// ********RoostGPT********
package main

import (
	"bytes"
	"errors"
	"net/http/httptest"
	"testing"
	"log"
	"os"
	"github.com/gorilla/mux"
	"github.com/mmorejon/microservices-docker-go-mongodb/movies/pkg/models"
	"github.com/stretchr/testify/assert"
)

type MockMovieModel struct {
	insert func(m models.Movie) (InsertResult, error)
}

func (m *MockMovieModel) Insert(movie models.Movie) (InsertResult, error) {
	if m.insert != nil {
		return m.insert(movie)
	}
	return InsertResult{}, nil
}

func TestInsert(t *testing.T) {
	mux := mux.NewRouter()

	// Setup logger
	errorLog := log.New(os.Stderr, "ERROR\t", log.Ldate|log.Ltime|log.Lshortfile)
	infoLog := log.New(os.Stdout, "INFO\t", log.Ldate|log.Ltime)

	// Scenario 1: Test for Valid Movie Insert
    t.Run("Test for Valid Movie Insert", func(t *testing.T) {
		// Arrange
        movies := &MockMovieModel{insert: func(m models.Movie) (InsertResult, error) {
			assert.Equal(t, m.Name, "Inception")
			return InsertResult{ID: "123"}, nil
		}}

		app := &application{
			errorLog: errorLog,
			infoLog:  infoLog,
			movies:   movies,
		}

		movie := models.Movie{Name: "Inception"}
		movieJson, _ := json.Marshal(movie)
		request := httptest.NewRequest("POST", "/insert", bytes.NewBuffer(movieJson))
		response := httptest.NewRecorder()

		// Act
		app.insert(response, request)

		// Assert
		assert.Equal(t, http.StatusOK, response.Code)
	})

	// Scenario 2: Invalid Movie Data
	t.Run("Invalid Movie Data", func(t *testing.T) {
		// Arrange
		movies := &MockMovieModel{}

		app := &application{
			errorLog: errorLog,
			infoLog:  infoLog,
			movies:   movies,
		}

		request := httptest.NewRequest("POST", "/insert", bytes.NewBuffer([]byte{"BadData"}))
		response := httptest.NewRecorder()

		// Act
		app.insert(response, request)

		// Assert
		assert.Equal(t, http.StatusInternalServerError, response.Code)
	})

	// Scenario 3: Database Insert Failure
	t.Run("Database Insert Failure", func(t *testing.T) {
		// Arrange
		movies := &MockMovieModel{insert: func(m models.Movie) (InsertResult, error) {
			return InsertResult{}, errors.New("database error")
		}}

		app := &application{
			errorLog: errorLog,
			infoLog:  infoLog,
			movies:   movies,
		}

		movie := models.Movie{Name: "Inception"}
		movieJson, _ := json.Marshal(movie)
		request := httptest.NewRequest("POST", "/insert", bytes.NewBuffer(movieJson))
		response := httptest.NewRecorder()

		// Act
		app.insert(response, request)

		// Assert
		assert.Equal(t, http.StatusInternalServerError, response.Code)
	})
}
