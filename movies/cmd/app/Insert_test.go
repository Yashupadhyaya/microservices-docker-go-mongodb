// ********RoostGPT********
/*
Test generated by RoostGPT for test azure-test-assistent using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=insert_6526688601
ROOST_METHOD_SIG_HASH=insert_f90e997c71

Scenario 1: Happy path - Inserting a valid new movie
Details:
    Description: The purpose of this test is to verify the successful execution of the function when a valid new movie is expected to be inserted.
Execution:
    Arrange: Create a valid new movie mock object with acceptable fields.
    Act: Call the `insert` function, passing in the mocked request which contains the movie object.
    Assert: Verify that no error is returned and the insertedID matches the mock's created movie id.
Validation:
    The assertion checks that if the right parameters are passed to the method, it should execute successfully without any errors, and return the right ID. It is necessary to confirm the function's primary use case - adding a new movie.

Scenario 2: Invalid JSON structure of Movie 
Details:
    Description: This test simulates the scenario where an invalid JSON movie object is supplied.
Execution:
    Arrange: Create an invalid movie object that does not correspond to the the movie's model struct.
    Act: Call the `insert` function passing the invalid movie object.
    Assert: Check that the function returns the appropriate error message.
Validation:
    It is important to validate that the function is able to properly handle invalid input and return corresponding error messages as this enhances robustness of the program.

Scenario 3: Inserting a duplicate movie
Details:
    Description: This test scenario is designed to check the function's capacity to handle duplicate movies.
Execution:
    Arrange: Invoke the function twice with the same movie object.
    Act: Call the `insert` method twice with the same movie object.
    Assert: Check that an error is returned the second time the function is invoked.
Validation:
    Assertion checks for error in second function invocation, we expect duplicate entries to be handled properly either by rejecting duplicates or updating the existing entry. This test is important to ensure data integrity in our movie storage.

Scenario 4: Testing database failure during the insert operation
Details:
    Description: This test is meant to check resilience of the function when the database operation fails.
Execution:
    Arrange: Mock the database operation to force it to return an error during insert operation.
    Act: Invoke the `insert` method with a valid movie object.
    Assert: Check that the function returns the database error.
Validation: 
    It is important to ensure that any database errors do not break the entire function and also that such errors are properly logged. This ensures error resilience and makes debugging easier.

*/

// ********RoostGPT********
package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/gorilla/mux"
	"github.com/mmorejon/microservices-docker-go-mongodb/movies/pkg/models"
	"github.com/stretchr/testify/assert"
	"io/ioutil"
	"log"
	"net/http"
	"net/http/httptest"
	"os"
	"testing"
)

// Mock movie model
type MovieModelMock struct {
}

func (mmm MovieModelMock) Insert(m models.Movie) (*models.InsertOneResult, error) {
	if m.Name == "Duplicate" {
		return nil, errors.New("duplicate entry")
	}
	
	if m.Name == "DB failure" {
		return nil, errors.New("database failure")
	}
	
	id := "mock_id"
	if m.Name == "Valid Movie" {
		id = m.ID
	}
	
	return &models.InsertOneResult{InsertedID: id}, nil
}

func TestInsert(t *testing.T) {
	// Arrange
	logger := log.New(ioutil.Discard, "INFO ", log.LstdFlags)
	app := &application{
		infoLog:  logger,
		errorLog: logger,
		movies:   &MovieModelMock{},
	}

	// Test Cases
	tests := []struct {
		name string
		movie  models.Movie
		expectedResponse string
		expectError bool
	} {
		{
			name: "Happy Path - Successful Insertion",
			movie:  models.Movie{
				Name: "Valid Movie",
				Year: 2021,
				Director: "Director Example",
				Genres: []string{},
			},
			expectedResponse: "New movie have been created, id=mock_id\n",
			expectError: false,
		},
		{
			name: "Invalid JSON structure of Movie",
			movie:  models.Movie{
				Name: "Invalid",
				Year: 2021,
			},
			expectedResponse: "http: superfluous response.WriteHeader call from main.application.serverError (main.go:???)",
			expectError: true,
		},
		{
			name: "Inserting a Duplicate Movie",
			movie: models.Movie{
				Name: "Duplicate",
				Year: 2021,
				Director: "Director Example",
				Genres: []string{},
			},
			expectedResponse: "http: superfluous response.WriteHeader call from main.application.serverError (main.go:???)",
			expectError: true,
		},
		{
			name: "Database failure during insert",
			movie: models.Movie{
				Name: "DB failure",
				Year: 2021,
				Director: "Director Example",
				Genres: []string{},
			},
			expectedResponse: "http: superfluous response.WriteHeader call from main.application.serverError (main.go:???)",
			expectError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			reqBody, _ := json.Marshal(tt.movie)
			req := httptest.NewRequest("POST", "/test", bytes.NewBuffer(reqBody))
			rr := httptest.NewRecorder()
			
			// Act
			r := mux.NewRouter()
			r.HandleFunc("/test", app.insert)
			r.ServeHTTP(rr, req)

			// Assert
			if tt.expectError {
				assert.Error(t, fmt.Fscan(rr.Body, &app.errorLog))
			} else {
				out, _ := ioutil.ReadAll(rr.Body)
				assert.Equal(t, tt.expectedResponse, string(out))
			}
		})
	}
}
