// ********RoostGPT********
/*
Test generated by RoostGPT for test go-test-assistent using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=insert_6526688601
ROOST_METHOD_SIG_HASH=insert_f90e997c71

Scenario 1: Test movie insertion with valid data
Details:
  Description: This test validates the insertion operation of a valid movie data to make sure the movie is inserted successfully.
Execution:
  Arrange: Create a mock request with movie data and mock the Movie Insert method to return a positive response.
  Act: Call the insert method with the mock request.
  Assert: Assert that the serverError method was not called and the insertedID returned by the Insert method is logged correctly.
Validation:
  We are asserting that the serverError method was not called for validation that no error occurred during the execution. The test is important in ensuring the movie addition feature works correctly with valid data.

Scenario 2: Test movie insertion with invalid data
Details:
  Description: This test validates the function's behavior when the input movie data is invalid.
Execution:
  Arrange: Create a mock request with invalid movie data.
  Act: Call the insert method with the mock request.
  Assert: Assert that the serverError method was called.
Validation:
  We are asserting that the serverError method was called showing an error occurred during the processing of the request. The test is important to make sure the function handles invalid data appropriately.

Scenario 3: Test movie insertion with nil request body
Details:
  Description: This test validates the function's behavior when the request body is nil.
Execution:
  Arrange: Create a mock request with nil body.
  Act: Call the insert method with the mock request.
  Assert: Assert that the serverError method was called.
Validation:
  The choice of assertion validates that the function was able to handle the error scenario of nil request body and properly logged the server error. The test is important to ensure function's robustness.

Scenario 4: Test movie insertion when database server is down
Details:
  Description: This test validates the function's behavior when there is a failure in connecting to the databases server.
Execution:
  Arrange: Mock the Movie Insert method to return an error.
  Act: Call the insert method with a valid request.
  Assert: Assert that the serverError method was called.
Validation:
  The assertion is examining that the serverError method was called, validating that an error was encountered during the database operation. The test is essential to test the graceful error handling of the function in case of any unexpected server errors.
*/

// ********RoostGPT********
package main

import (
	"bytes"
	"errors"
	"testing"
	"github.com/gorilla/mux"
	"github.com/mmorejon/microservices-docker-go-mongodb/movies/pkg/models"
	"net/http"
	"net/http/httptest"
	"os"
	"log"
	"github.com/stretchr/testify/assert"
)
 
func TestInsert(t *testing.T) {
	errorLog := log.New(os.Stdout, "ERROR\t", log.Ldate|log.Ltime)
	infoLog := log.New(os.Stdout, "INFO\t", log.Ldate|log.Ltime)

	testCases := []struct{
		name string
		movie models.Movie
		movieModel *models.MovieModel
		reqBody []byte
		expectServerError bool
	}{
		{
			name: "Test movie insertion with valid data",
			movie: models.Movie{
				Name: "Valid Movie",
				Year: "2000",
				Director: "Director",
				Writer: "Writer",
				Characters: []string{"Character1", "Character2"},
			},
			movieModel: &models.MovieModel{},
			reqBody: []byte(`{"Name":"Valid Movie","Year":"2000","Director":"Director","Writer":"Writer","Characters":["Character1","Character2"]}`),
			expectServerError: false,
		},
		{
			name: "Test movie insertion with invalid data",
			movie: models.Movie{},
			movieModel: &models.MovieModel{},
			reqBody: []byte(`{"Name":"Invalid Movie","Year":"2000"}`), // missing required fields
			expectServerError: true,
		},
		{
			name: "Test movie insertion with nil request body",
			movie: models.Movie{},
			movieModel: &models.MovieModel{},
			reqBody: nil,
			expectServerError: true,
		},
		{
			name: "Test movie insertion when database server is down",
			movie: models.Movie{
				Name: "Valid Movie",
				Year: "2000",
				Director: "Director",
				Writer: "Writer",
				Characters: []string{"Character1", "Character2"},
			},
			movieModel: &models.MovieModel{
				Err: errors.New("unable to connect to server"),
			},
			reqBody: []byte(`{"Name":"Valid Movie","Year":"2000","Director":"Director","Writer":"Writer","Characters":["Character1","Character2"]}`),
			expectServerError: true,
		},
	}
	

	for _, test := range testCases {
		t.Run(test.name, func(t *testing.T) {
			app := &application{
				errorLog: errorLog,
				infoLog:  infoLog,
				movies:   test.movieModel,
			}

			req, err := http.NewRequest("POST", "/movie", bytes.NewBuffer(test.reqBody))
			if err != nil {
				t.Fatal(err)
			}
			rr := httptest.NewRecorder()
			router := mux.NewRouter()

			router.HandleFunc("/movie", app.insert).Methods("POST")
			router.ServeHTTP(rr, req)

			assert.Equal(t, test.expectServerError, app.movies.CheckServerError(), "Unexpected server error condition")

			if test.expectServerError {
				assert.NotEqual(t, http.StatusOK, rr.Code, "Expected not Ok status, got %v", rr.Code)
			}else {
				assert.Equal(t, http.StatusOK, rr.Code, "Expected Ok status, got %v", rr.Code)
			}
		})
	}
}
