// ********RoostGPT********
/*
Test generated by RoostGPT for test go-test-assistent using AI Type  and AI Model 

ROOST_METHOD_HASH=all_f26e777913
ROOST_METHOD_SIG_HASH=all_c38f98e82e

Scenario 1: Successful retrieval of all movies

Details:
  Description: This test is meant to check if the function correctly retrieves all movies and sends them back to the client with the appropriate HTTP status and header. It simulates a scenario where the underlying movie storage is working correctly and contains some movies.
  
Execution:
  Arrange: Mock `app.movies.All()` to return a slice of `Movie` objects. Also, set up `app.infoLog` to capture its output.
  Act: Call `app.all()`.
  Assert: Check that the HTTP status is 200 OK, and that the response body contains a JSON representation of the movies. Also, check that `app.infoLog` contains the message "Movies have been listed".
  
Validation:
  The assertion confirms that the function behaves correctly under normal conditions. The expected result is formed based on the common HTTP standards of sending successful request data. The test is crucial in maintaining the application's behaviour of fetching all available movies from the database.

Scenario 2: Empty movies collection

Details:
  Description: This test checks if the function correctly handles an empty movies collection. It simulates a situation where the underlying movies service is working correctly but doesn't contain any movies.
  
Execution:
  Arrange: Mock `app.movies.All()` to return an empty slice. Also, setup `app.infoLog` to capture its output.
  Act: Call `app.all()`.
  Assert: Check that the HTTP status is 200 OK, and that the response body contains an empty JSON array. Also, check that `app.infoLog` contains the message "Movies have been listed".

Validation:
  Here the assertion verifies if the function appropriately responds to a situation with no available movies. The test is essential to ensure that users are correctly informed of the lack of content in certain situations.

Scenario 3: Database error when retrieving movies

Details:
  Description: This test checks if the function correctly handles a situation where a database error occurs while retrieving movies.
  
Execution:
  Arrange: Mock `app.movies.All()` to return an error. Setup `app.errorLog` to capture its output and `app.serverError()` to capture its inputs.
  Act: Call `app.all()`.
  Assert: Check that `app.serverError()` was called with an error and the http.ResponseWriter. Also, check that `app.errorLog` contains a log of the error.

Validation:
  The assertion confirms whether the function behaves as expected when a database error occurs. The test is vital to ensure the reliability and robustness of the application by catering for error scenarios.

Scenario 4: Error when marshalling movies to JSON

Details:
  Description: This test is meant to check if the function handles an error that occurs while marshalling the movie slice to JSON.
  
Execution:
  Arrange: Mock `app.movies.All()` to return a non-empty slice of `Movie` objects that can't be marshalled to JSON. Mock `json.Marshal()` to return an error. Setup `app.errorLog` to capture its output and `app.serverError()` to capture its inputs.
  Act: Call `app.all()`.
  Assert: Check that `app.serverError()` was called with a marshalling error and the http.ResponseWriter. Also, check that `app.errorLog` contains a log message about the marshalling error.

Validation:
  It's crucial that the function can handle errors while marshalling the movie data to JSON since sending malformed data to the client can cause unexpected behavior on the client-side.
*/

// ********RoostGPT********
package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"github.com/mmorejon/microservices-docker-go-mongodb/movies/pkg/models"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"testing"
)

func TestAll(t *testing.T) {
	// Test Data
	var movie1 = models.Movie{ID: "1", Name: "Movie 1", Year: 2001, Director: "Director 1", Genres: []string{"Comedy", "Action"}}
	var movie2 = models.Movie{ID: "2", Name: "Movie 2", Year: 2004, Director: "Director 2", Genres: []string{"Drama", "Thriller"}}

	var testCases = []struct {
		name          string
		mockError     error
		mockMovies    []*models.Movie
		expectedErr   bool
		expectedMovies []*models.Movie
		expectedStatus int
		expectedLog   string
	}{
		{
			name:          "Successful retrieval of all movies",
			mockError:     nil,
			mockMovies:    []*models.Movie{&movie1, &movie2},
			expectedErr:   false,
			expectedMovies:    []*models.Movie{&movie1, &movie2},
			expectedStatus: http.StatusOK,
			expectedLog:   "Movies have been listed",
		},
		{
			name:          "Empty movies collection",
			mockError:     nil,
			expectedErr:   false,
			expectedMovies:    nil,
			expectedStatus: http.StatusOK,
			expectedLog:   "Movies have been listed",
		},
		{
			name:          "Database error when retrieving movies",
			mockError:     errors.New("database error"),
			expectedErr:   true,
			expectedStatus: http.StatusInternalServerError,
		},
		{
			name:          "Error when marshalling movies to JSON",
			mockError:     nil,
			mockMovies:    []*models.Movie{&movie1, &{ID: "bad", Name: "\xbd\xb2"}},
			expectedErr:   true,
			expectedStatus: http.StatusInternalServerError,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Mock the All() function
			oldAll := All
			defer func() { All = oldAll }()
			All = func() ([]*models.Movie, error) {
				return tc.mockMovies, tc.mockError
			}

			// Prepare a new HTTP request
			req, err := http.NewRequest(http.MethodGet, "/movies", nil)
			if err != nil {
				t.Fatal(err)
			}

			// Send the HTTP request to our function
			rr := httptest.NewRecorder()
			app := application{
				errorLog: log.New(ioutil.Discard, "", log.LstdFlags),
				infoLog: log.New(&buf, "", log.LstdFlags),
				movies: &mockMovieModel{},
			}
			app.all(rr, req)

			// Check whether the status of the response is as expected
			if rr.Code != tc.expectedStatus {
				t.Errorf("want status %d; got %d", tc.expectedStatus, rr.Code)
			}
			
			// Check the serverError function call based on expectedErr
                        if tc.expectedErr {
                                if !app.errorLog.recorded {
                                        t.Error("Expected serverError to be called, but it wasn't")
                                }
                        } else if app.errorLog.recorded {
                                t.Error("Expected serverError not to be called, but it was")
                        }

			// Finally, check the response body
			if !tc.expectedErr && rr.Code == http.StatusOK {
				body, _ := ioutil.ReadAll(rr.Body)
				var movies []*models.Movie
				if err = json.Unmarshal(body, &movies); err != nil {
					t.Fatal(err)
				}
				if !reflect.DeepEqual(movies, tc.expectedMovies) {
					t.Errorf("Expected movies %v; got %v", tc.expectedMovies, movies)
				}
			}
		})
	}
}
