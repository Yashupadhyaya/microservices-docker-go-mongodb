// ********RoostGPT********
/*
Test generated by RoostGPT for test azure-test-assistent using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=delete_3e4258cdec
ROOST_METHOD_SIG_HASH=delete_34a6d37f68

Scenario 1: Successful Deletion of a Movie

Details:
  Description: This test checks if the delete function works correctly when provided with a valid movie ID. It checks whether the movie is successfully deleted from the database.
  
Execution:
  Arrange: Mock the movie model's Delete function to simulate a successful deletion operation, and the movie ID provided to vars["id"] exists in the mock database. 
  Act: Invoke the delete function with the mock request.
  Assert: Check whether the deleteResult returned from the app.movie.Delete method call equals to the mocked deleteResult. Also inspect the Logger's output to ensure it printed the correct success message.
  
Validation:
  The assertion verifies that the Delete function behaves as expected when it encounters valid inputs and conditions. This test is important because deleting movies is a basic operation that the application should perform 

Scenario 2: Delete function with Invalid movie ID

Details:
  Description: This test checks if the delete function responds appropriately when provided with an invalid movie ID. It checks whether the appropriate error is returned when the movie doesn't exist.

Execution:
  Arrange: Mock the movie model's Delete function to return an error indicating that the movie ID does not exist in the database. 
  Act: Invoke the delete function with the mock request.
  Assert: Check whether the appropriate error was returned and the Logger's output is as expected.
  
Validation:
  This test verifies if the delete function behaves as expected with invalid inputs. The application should be robust enough to handle such situations in a reasonable manner.

Scenario 3: Delete function when database is unreachable 

Details:
  Description: This test checks if the delete function responds appropriately when the database is unreachable. 

Execution:
  Arrange: Mock the movie model's Delete function to return an error indicating a database connectivity issue.
  Act: Invoke the delete function with the mock request.
  Assert: Check whether the appropriate error was returned and the Logger's output is as expected.

Validation:
  This test verifies if the delete function responds correctly when it encounters infrastructure issues, such as an unreachable database. Ensuring that the application handles such issues effectively is crucial for maintaining runtime stability.  

Scenario 4: Delete function with no movie ID provided

Details:
  Description: This test checks how the delete function responds when supplied with a request that doesn't include a movie ID.

Execution:
  Arrange: Setup the request without including a movie ID in vars["id"].
  Act: Invoke the delete function with the mock request.
  Assert: Check whether the appropriate error was returned and the Logger's output is as expected.
  
Validation:
  This test verifies that the delete function responds appropriately to misformed requests. It's important for the application to identify and reject such requests rather than behaving unpredictably.
*/

// ********RoostGPT********
package main

import (
	"bytes"
	"errors"
	"github.com/gorilla/mux"
	"github.com/stretchr/testify/assert"
	"io/ioutil"
	"log"
	"net/http"
	"net/http/httptest"
	"os"
	"testing"
	"github.com/mmorejon/microservices-docker-go-mongodb/movies/pkg/models"
)

type mockMovieModel struct {
	DeleteFunc func(id string) (*models.DeleteResult, error)
}

func (m *mockMovieModel) Delete(id string) (*models.DeleteResult, error) {
	return m.DeleteFunc(id)
}

func TestDelete(t *testing.T) {
	tests := []struct {
		name           string
		movieID        string
		model          mockMovieModel
		expectedStatus int
		expectedBody   string
	}{
		{
			"Successful Deletion of a Movie",
			"123",
			mockMovieModel{
				DeleteFunc: func(id string) (*models.DeleteResult, error) {
					return &models.DeleteResult{DeletedCount: 1}, nil
				},
			},
			http.StatusOK,
			"Have been eliminated 1 movie(s)",
		},
		{
			"Delete function with Invalid movie ID",
			"999",
			mockMovieModel{
				DeleteFunc: func(id string) (*models.DeleteResult, error) {
					return &models.DeleteResult{DeletedCount: 0}, errors.New("movie not found")
				},
			},
			http.StatusInternalServerError,
			"movie not found",
		},
		{
			"Delete function when database is unreachable",
			"123",
			mockMovieModel{
				DeleteFunc: func(id string) (*models.DeleteResult, error) {
					return nil, errors.New("db is unreachable")
				},
			},
			http.StatusInternalServerError,
			"db is unreachable",
		},
		{
			"Delete function with no movie ID provided",
			"",
			mockMovieModel{
				DeleteFunc: func(id string) (*models.DeleteResult, error) {
					return nil, errors.New("no movie ID provided")
				},
			},
			http.StatusInternalServerError,
			"no movie ID provided",
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			var buf bytes.Buffer
			app := &application{
				errorLog: log.New(&buf, "", 0),
				infoLog:  log.New(&buf, "", 0),
				movies:   &test.model,
			}
			req, _ := http.NewRequest(http.MethodDelete, "", nil)

			rctx := mux.NewRouter()
			req = mux.SetURLVars(req, map[string]string{
				"id": test.movieID,
			})

			rr := httptest.NewRecorder()
			app.delete(rr, req)

			responseBody, _ := ioutil.ReadAll(rr.Body)
			assert.Contains(t, string(responseBody), test.expectedBody)

			// Check the status code.
			assert.Equal(t, test.expectedStatus, rr.Code)

			// Check the log output.
			logOutput := buf.String()
			if test.expectedStatus == http.StatusOK {
				assert.Contains(t, logOutput, test.expectedBody)
			} else {
				assert.Contains(t, logOutput, test.expectedBody)
			}
		})
	}
}
