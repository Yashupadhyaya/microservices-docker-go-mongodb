// ********RoostGPT********
/*
Test generated by RoostGPT for test azure-test-assistent using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=findByID_3f59747bbe
ROOST_METHOD_SIG_HASH=findByID_cab6a16c94

Scenario 1: Valid ID Provided and Movie Exists in Store

Details:
    Description: This test is meant to verify that the findByID function correctly fetches and returns a movie when a valid ID is provided, and the movie exists in the store. This is a test of the function's normal operation.
Execution:
    Arrange: Initialise the application with mocked "InfoLog" and "movies". Set up a movie in mocked "movies store" with a known ID.
    Act: Invoke the findByID function with the known ID.
    Assert: Check that the returned HTTP status code is 200(ok), 'Content-Type' is 'application/json', and the response body matches the movie associated with the known ID.
Validation:
    This assertion checks that the function correctly fetches the movie when the ID exists in the mocked data store. If the function delivers as expected, it validates that it behaves properly given proper input. It is important because it guarantees that the service will provide the correct movie data when queried with a specific ID.

Scenario 2: Invalid ID Provided

Details:
    Description: This test is to check if the findByID function handles an 'Invalid ID' correctly i.e., it logs an informative error message and produces an appropriate server error response.
Execution:
    Arrange: Set up the system with a mocked "InfoLog" and "movies". 
    Act: Invoke the findByID function with an invalid ID.
    Assert: Check that 'InfoLog' logs the message 'Movie not found', and the error response with the appropriate server error and message.
Validation:
    This test ensures that the function can handle an invalid ID without crashing, and it provides appropriate feedback. This is especially important in ensuring that the application doesn't abruptly fail and instead provides meaningful error messages to the client for better debugging and usability.

Scenario 3: Valid ID Provided but Movie Does Not Exist in Store

Details:
    Description: This test is meant to verify that the findByID function handles the case when a valid ID is provided, but no corresponding movie exists in the store.
Execution:
    Arrange: Set up the system with a mocked 'InfoLog' and 'movies'. Ensure that the movies store does not contain a movie with the ID to be used for testing.
    Act: Invoke the findByID function with the known but non-existent movie ID.
    Assert: Check that 'InfoLog' logs the message 'Movie not found'.
Validation:
    This test ensures that the function handles non-existent IDs correctly, logging an appropriate message. This test is important to confirm that the application behaves gracefully when asked to fetch a movie that does not exist.

Scenario 4: Error Occurs During JSON Marshalling

Details:
    Description: This test is meant to verify that the findByID function can handle errors that occur during JSON marshalling of the movie data.
Execution:
    Arrange: Set up the system with a mocked 'InfoLog + MovieModel' capable of returning a struct that causes json.Marshal to return an error.
    Act: Invoke the findByID function with a valid movie ID.
    Assert: Check that 'InfoLog' logs the relevant error message and server error is returned accordingly.
Validation:
    This test ensures that the function appropriately handles internal errors that occur during operation, thus verifying its resiliency and robustness in the face of unexpected situations.

*/

// ********RoostGPT********
package main

import (
	"bytes"
	"errors"
	"io"
	"log"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/gorilla/mux"
	"github.com/mmorejon/microservices-docker-go-mongodb/movies/pkg/models"
)

type MovieModelMock struct {
	data map[string]*models.Movie
}

func (mm *MovieModelMock) FindByID(id string) (*models.Movie, error) {
	if movie, ok := mm.data[id]; ok {
		return movie, nil
	}
	return nil, errors.New("ErrNoDocuments")
}

func TestFindById(t *testing.T) {
	infoLogBuf := new(bytes.Buffer)
	errorLogBuf := new(bytes.Buffer)
	infoLog := log.New(io.MultiWriter(infoLogBuf), "", log.LstdFlags)
	errorLog := log.New(io.MultiWriter(errorLogBuf), "", log.LstdFlags)

	tests := []struct {
		testName   string
		url        string
		wantStatus int
		setupMock  func(*MovieModelMock)
	}{
		{
			testName:   "ValidID_MovieExists",
			url:        "/1234",
			wantStatus: http.StatusOK,
			setupMock: func(mm *MovieModelMock) {
				mm.data["1234"] = &models.Movie{ID: "1234", Name: "The Avengers"}
			},
		},
		{
			testName:   "ValidID_MovieNotExists",
			url:        "/9999",
			wantStatus: http.StatusNotFound,
			setupMock: func(mm *MovieModelMock) {},
		},
		{
			testName:   "InvalidID_Format",
			url:        "/abcd",
			wantStatus: http.StatusBadRequest,
			setupMock: func(mm *MovieModelMock) {},
		},
	}

	for _, tt := range tests {
		t.Run(tt.testName, func(t *testing.T) {
			// Arrange
			movieModelMock := &MovieModelMock{
				data: make(map[string]*models.Movie),
			}
			tt.setupMock(movieModelMock)

			app := application{
				errorLog: errorLog,
				infoLog:  infoLog,
				movies:   movieModelMock,
			}

			router := mux.NewRouter()
			router.HandleFunc("/{id:[0-9]+}", app.findByID)

			request, err := http.NewRequest(http.MethodGet, tt.url, nil)
			if err != nil {
				t.Fatal(err)
			}

			// Act
			responseRecorder := httptest.NewRecorder()
			router.ServeHTTP(responseRecorder, request)

			// Assert
			if responseRecorder.Code != tt.wantStatus {
				t.Errorf("Want status %d, got %d", tt.wantStatus, responseRecorder.Code)
			}
			t.Log("Status asserted")
		})
	}
}
