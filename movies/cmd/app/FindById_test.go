// ********RoostGPT********
/*
Test generated by RoostGPT for test go-test-assistent using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=findByID_3f59747bbe
ROOST_METHOD_SIG_HASH=findByID_cab6a16c94

Scenario 1: Movie Found by ID

Details:
  Description: This test checks that the findByID function works properly under normal conditions. Given a valid ID that maps to an existing movie, findByID should return a JSON representation of the movie.
Execution:
  Arrange: Mock the method movies.FindByID to return a valid movie data for a given ID. Also, mock the http.ResponseWriter to record the response for later examination.
  Act: Call findByID method with the provided ID.
  Assert: Assert that the method returned the correct HTTP status code (200), the Content-Type header is set to "application/json", and the response body matches the expected JSON representation of the movie.
Validation:
  The intended behavior of the function under normal conditions is very important to verify. This ensures that the function reliably delivers expected functionality and contributes to the overall utility of the service.

Scenario 2: Movie Not Found

Details:
  Description: This test checks the scenario where the movie ID doesn't map to any existing movie. The function should log "Movie not found" to infoLog.
Execution:
  Arrange: Mock the method movies.FindByID to return an "ErrNoDocuments" error for a given ID. Also, mock the logger to record the logs for later examination.
  Act: Call findByID method with the provided ID.
  Assert: Assert that the infoLog received an exact match for the message "Movie not found".
Validation:
  This test ensures that the function handles data validation errors and communicates them effectively to the client and for internal logging purposes.

Scenario 3: Error on Finding Movie

Details:
  Description: This test confirms the function behaviour under scenarios where an error occurs during movie search. The function is expected to call the serverError handler to manage the error.
Execution:
  Arrange: Mock the method movies.FindByID to return a non-"ErrNoDocuments" error for a given ID. Substitute the serverError method with a test double that records if it was called and what parameters it received.
  Act: Call findByID method with the provided ID.
  Assert: Confirm that the serverError test double was called once with the correct parameters.
Validation:
  It's important to verify that errors from internal service calls are correctly caught and handled. This ensures the robustness of the service.

Scenario 4: Error on Marshalling

Details:
  Description: This test investigates the function behaviour when an error occurs in json marshalling. The function should handle this error by calling the serverError function.
Execution:
  Arrange: Mock the movies.FindByID method to return a valid movie for the given ID. Substitute the json.Marshal method with a function that always throws an error and the serverError method with a test double.
  Act: Call the findByID method with the provided ID.
  Assert: Confirm that the serverError test double was invoked once with appropriate parameters.
Validation:
  This test scenario is important because it checks if the application can handle errors during the marshalling process. In case of any marshalling error, the application should respond effectively without breaking down. This test ensures the resilience of the service.

*/

// ********RoostGPT********
package main

import (
	"bytes"
	"errors"
	"log"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"

	"github.com/gorilla/mux"
	"github.com/mmorejon/microservices-docker-go-mongodb/movies/pkg/models"
)

// Structs for mocking.
type MockMovieModel struct {
	Movie *models.Movie
	Err   error
}

func (m *MockMovieModel) FindByID(id string) (*models.Movie, error) {
	return m.Movie, m.Err
}

// TestFindByID tests the findByID function.
func TestFindById(t *testing.T) {

	ErrNoDocumentsMock := errors.New("ErrNoDocuments")

	mockMovie := &models.Movie{
		ID:      "123",
		Title:   "Test Movie",
		Year:    2022,
		Direct:  []string{"Test Director"},
		Writers: []string{"Test Writer"},
	}

	testCases := []struct {
		Name           string
		Path           string
		MovieModel     *MockMovieModel
		ExpectHTTPCode int
		ExpectContains []string
	}{
		{
			"Movie Found by ID",
			"/123",
			&MockMovieModel{
				Movie: mockMovie,
				Err:   nil,
			},
			http.StatusOK,
			[]string{"Have been found a movie", mockMovie.ID},
		},
		{
			"Movie Not Found",
			"/789",
			&MockMovieModel{
				Movie: nil,
				Err:   ErrNoDocumentsMock,
			},
			http.StatusOK,
			[]string{"Movie not found"},
		},
		{
			"Error on Finding Movie",
			"/456",
			&MockMovieModel{
				Movie: nil,
				Err:   errors.New("unexpected error"),
			},
			http.StatusInternalServerError,
			[]string{"Error finding movie"},
		},
	}

	for _, tt := range testCases {
		t.Run(tt.Name, func(t *testing.T) {
			infoLog := log.New(os.Stdout, "INFO\t", log.Ldate|log.Ltime)
			app := &application{
				errorLog: log.New(os.Stdout, "ERROR\t", log.Ldate|log.Ltime|log.Lshortfile),
				infoLog:  infoLog,
				movies:   tt.MovieModel,
			}

			r := mux.NewRouter()
			r.HandleFunc("/{id}", app.findByID)
			ts := httptest.NewServer(r)
			defer ts.Close()

			res, err := http.Get(ts.URL + tt.Path)
			if err != nil {
				t.Fatal(err)
			}

			if res.StatusCode != tt.ExpectHTTPCode {
				t.Errorf("Expected HTTP response code %d but got %d", tt.ExpectHTTPCode, res.StatusCode)
			}

			for _, s := range tt.ExpectContains {
				if !strings.Contains(res.Body.String(), s) {
					t.Errorf("Expected response to contain %q", s)
				}
			}
		})
	}
}
